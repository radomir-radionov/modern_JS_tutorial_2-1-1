///  Modern JavaScript tutorial  ///

// ЧАСТЬ 2
// Браузер: документ, события, интерфейсы
// Изучаем работу со страницей – как получать элементы, манипулировать их размерами,
// динамически создавать интерфейсы и взаимодействовать с посетителем.

// 1.1 Браузерное окружение, спецификации

// Каждая среда предоставляет свою функциональность, которую спецификация JavaScript называет окружением.
// Окружение предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым.
// имеется корневой объект window, который выступает в 2 ролях:
// Во-первых, это глобальный объект(Глобальный объект предоставляет переменные и функции, доступные в любом месте программы.)
// для JavaScript-кода, об этом более подробно говорится в главе Глобальный объект.
// Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.

// DOM (Document Object Model)
// Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое
//  страницы в виде объектов, которые можно менять.
//  Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
//  DOM – не только для браузеров
// Спецификация DOM описывает структуру документа и предоставляет объекты для манипуляций со страницей.

// BOM (Browser Object Model)
// Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты,
//  предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.
// Например:
// Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его
// свойств самыми известными являются: navigator.userAgent – информация о текущем браузере,
// и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
// Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.

// Итого
// Говоря о стандартах, у нас есть:
// Спецификация DOM
// описывает структуру документа, манипуляции с контентом и события, подробнее на https://dom.spec.whatwg.org.
// Спецификация CSSOM
// Описывает файлы стилей, правила написания стилей и манипуляций с ними, а также то, как это всё связано со страницей,
// подробнее на https://www.w3.org/TR/cssom-1/.
// Спецификация HTML
// Описывает язык HTML (например, теги) и BOM (объектную модель браузера) – разные функции браузера: setTimeout, alert,
// location и так далее, подробнее на https://html.spec.whatwg.org. Тут берётся за основу спецификация DOM и
// расширяется дополнительными свойствами и методами.

// 1.2 DOM-дерево

// Основой HTML-документа являются теги.
// В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом.
// Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.
// DOM – это представление HTML-документа в виде дерева тегов.
// Каждый узел этого дерева – это объект.
// Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: <html> – это корневой узел,
// <head> и <body> его дочерние узлы и т.д.
// Текст внутри элементов образует текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку текста.
// У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.
// Существует всего два исключения из этого правила:
// По историческим причинам пробелы и перевод строки перед тегом <head> игнорируются
// Если мы записываем что-либо после закрывающего тега </body>, браузер автоматически перемещает эту запись в конец body,
//  поскольку спецификация HTML требует, чтобы всё содержимое было внутри <body>. Поэтому после закрывающего тега </body>
//  не может быть никаких пробелов.

//  Автоисправление
// Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.
// Таблицы всегда содержат <tbody></tbody>

// Другие типы узлов
// Есть и некоторые другие типы узлов, кроме элементов и текстовых узлов.
// Например, узел-комментарий:
// Все, что есть в HTML, даже комментарии, является частью DOM.

// Существует 12 типов узлов. Но на практике мы в основном работаем с 4 из них:

// document – «входная точка» в DOM.
// узлы-элементы – HTML-теги, основные строительные блоки.
// текстовые узлы – содержат текст.
// комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.
// В правой части инструментов разработчика находятся следующие подразделы:
// Styles – здесь мы видим CSS, применённый к текущему элементу: правило за правилом, включая встроенные стили (выделены серым).
// Почти всё можно отредактировать на месте, включая размеры, внешние и внутренние отступы.
// Computed – здесь мы видим итоговые CSS-свойства элемента, которые он приобрёл в результате применения всего каскада стилей
// (в том числе унаследованные свойства и т.д.).
// Event Listeners – в этом разделе мы видим обработчики событий, привязанные к DOM-элементам (мы поговорим о них в следующей части учебника).
// … и т.д.

// Итого;
// HTML/XML документы представлены в браузере в виде DOM-дерева.
// Теги становятся узлами-элементами и формируют структуру документа.
// Текст становится текстовыми узлами.
// … и т.д. Всё, что записано в HTML, есть и в DOM-дереве, даже комментарии.
// Для изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.

// 1.3 Навигация по DOM-элементам

// DOM позволяет нам делать что угодно с элементами и их содержимым, но для начала нужно получить соответствующий DOM-объект.
// Все операции с DOM начинаются с объекта document. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.
// document.body может быть равен null
// В DOM значение null значит «не существует» или «нет такого узла».
// Дети: childNodes, firstChild, lastChild
// Коллекция childNodes содержит список всех детей, включая текстовые узлы.
// Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему дочернему элементу.

// DOM-коллекции
// Как мы уже видели, childNodes похож на массив. На самом деле это не массив, а коллекция – особый перебираемый объект-псевдомассив.
// Для перебора коллекции мы можем использовать for..of:
// for (let node of document.body.childNodes) {
//   alert(node); // покажет все узлы из коллекции
// }
// Это работает, потому что коллекция является перебираемым объектом (есть требуемый для этого метод Symbol.iterator).
// Методы массивов не будут работать, потому что коллекция – это не массив

// DOM-коллекции – только для чтения
// DOM-коллекции живые
// Не используйте цикл for..in для перебора коллекций

// Соседи и родитель
// Соседи – это узлы, у которых один и тот же родитель.
// Родитель доступен через parentNode.

// Навигация только по элементам
// дополнительный набор ссылок, которые учитывают только узлы-элементы:
// children – коллекция детей, которые являются элементами.
// firstElementChild, lastElementChild – первый и последний дочерний элемент.
// previousElementSibling, nextElementSibling – соседи-элементы.
// parentElement – родитель-элемент.
// Свойство parentElement возвращает родитель-элемент, а parentNode возвращает «любого родителя».
// Обычно эти свойства одинаковы: они оба получают родителя.
// Ещё немного ссылок: таблицы
// Элемент <table>, в дополнение к свойствам, о которых речь шла выше, поддерживает следующие:
// table.rows – коллекция строк <tr> таблицы.
// table.caption/tHead/tFoot – ссылки на элементы таблицы <caption>, <thead>, <tfoot>.
// table.tBodies – коллекция элементов таблицы <tbody> (по спецификации их может быть больше одного).
// <thead>, <tfoot>, <tbody> предоставляют свойство rows:
// tbody.rows – коллекция строк <tr> секции.
// <tr>:
// tr.cells – коллекция <td> и <th> ячеек, находящихся внутри строки <tr>.
// tr.sectionRowIndex – номер строки <tr> в текущей секции <thead>/<tbody>/<tfoot>.
// tr.rowIndex – номер строки <tr> в таблице (включая все строки таблицы).
// <td> and <th>:
// td.cellIndex – номер ячейки в строке <tr>.

// Итого
// Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.
// Есть два основных набора ссылок:
// Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
// Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.
// Некоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому.

// 1.4 Поиск: getElement*, querySelector*

// document.getElementById или просто id
// Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id), где бы он ни находился.
// Значение id должно быть уникальным
// Только document.getElementById, а не anyElem.getElementById
// Метод getElementById можно вызвать только для объекта document. Он осуществляет поиск по id по всему документу.
// querySelectorAll
// Самый универсальный метод поиска – это elem.querySelectorAll(css), он возвращает все
// элементы внутри elem, удовлетворяющие данному CSS-селектору.
// Псевдоклассы тоже работают
// Псевдоклассы в CSS-селекторе, в частности :hover и :active, также поддерживаются. Например,
// document.querySelectorAll(':hover') вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему)
// из текущих элементов под курсором мыши.

// matches
// Предыдущие методы искали по DOM.
// Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.
// if (elem.matches('a[href$="zip"]'))

// closest
// Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.
// Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей.
// Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.

// getElementsBy*
// На данный момент, они скорее исторические, так как querySelector более чем эффективен.
// Здесь мы рассмотрим их для полноты картины, также вы можете встретить их в старом коде.
// elem.getElementsByTagName(tag) ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
// elem.getElementsByClassName(className) возвращает элементы, которые имеют данный CSS-класс.
// document.getElementsByName(name) возвращает элементы с заданным атрибутом name. Очень редко используется.

// Живые коллекции
// Все методы "getElementsBy*" возвращают живую коллекцию.
// Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
// Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.
// Итого
// Есть 6 основных методов поиска элементов в DOM:

// Метод	Ищет по...	Ищет внутри элемента?	Возвращает живую коллекцию?
// querySelector	CSS-selector	✔	-
// querySelectorAll	CSS-selector	✔	-
// getElementById	id	-	-
// getElementsByName	name	-	✔
// getElementsByTagName	tag or '*'	✔	✔
// getElementsByClassName	class	✔	✔
// Безусловно, наиболее часто используемыми в настоящее время являются методы querySelector и querySelectorAll,
//  но и методы getElement(s)By* могут быть полезны в отдельных случаях, а также встречаются в старом коде.
// Кроме того:
// Есть метод elem.matches(css), который проверяет, удовлетворяет ли элемент CSS-селектору.
// Метод elem.closest(css) ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору. Сам элемент также включён в поиск.
// И, напоследок, давайте упомянем ещё один метод, который проверяет наличие отношений между предком и потомком:
// elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.

// 1.5 Свойства узлов: тип, тег и содержимое

// Классы DOM-узлов
// У разных DOM-узлов могут быть разные свойства. (a   input)
// Существуют следующие классы:
// Существуют следующие классы:
// EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются. Он служит основой,
// благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

// Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность:
//  parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. Но есть определённые
//   классы узлов, которые наследуют от него: Text – для текстовых узлов, Element – для узлов-элементов и более экзотический
//   Comment – для узлов-комментариев.

// Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: nextElementSibling, children
// и методы поиска: getElementsByTagName, querySelector. Браузер поддерживает не только HTML, но также XML и SVG. Класс Element
//  служит базой для следующих классов: SVGElement, XMLElement и HTMLElement.

// HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы:
// HTMLInputElement – класс для тега <input>,
// HTMLBodyElement – класс для тега <body>,
// HTMLAnchorElement – класс для тега <a>,

// Для того, чтобы узнать имя класса DOM-узла, вспомним, что обычно у объекта есть свойство constructor.
//  Оно ссылается на конструктор класса, и в свойстве constructor.name содержится его имя:
// alert( document.body.constructor.name ); // HTMLBodyElement
// …Или мы можем просто привести его к строке:
// alert( document.body ); // [object HTMLBodyElement]
// Проверить наследование можно также при помощи instanceof

// Как видно, DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.
// console.dir(elem) и console.log(elem)
// Большинство браузеров поддерживают в инструментах разработчика две команды: console.log и console.dir.
//  Они выводят свои аргументы в консоль. Для JavaScript-объектов эти команды обычно выводят одно и то же.
// Но для DOM-элементов они работают по-разному:
// console.log(elem) выводит элемент в виде DOM-дерева.
// console.dir(elem) выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

// Свойство «nodeType»
// Свойство nodeType предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.
// Его значением является цифра:
// elem.nodeType == 1 для узлов-элементов,
// elem.nodeType == 3 для текстовых узлов,
// elem.nodeType == 9 для объектов документа,
// В спецификации можно посмотреть остальные значения.
// В современных скриптах, чтобы узнать тип узла, мы можем использовать метод instanceof и другие способы проверить класс,
// но иногда nodeType проще использовать. Мы не можем изменить значение nodeType, только прочитать его.

// Тег: nodeName и tagName
// Получив DOM-узел, мы можем узнать имя его тега из свойств nodeName и tagName:
// Есть ли какая-то разница между tagName и nodeName?
// Да, она отражена в названиях свойств, но не очевидна.
// Свойство tagName есть только у элементов Element.
// Свойство nodeName определено для любых узлов Node:
// для элементов оно равно tagName.
// для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.
// Другими словами, свойство tagName есть только у узлов-элементов (поскольку они происходят от класса Element),
// а nodeName может что-то сказать о других типах узлов.

//  innerHTML: содержимое элемента
// Свойство innerHTML позволяет получить HTML-содержимое элемента в виде строки.
// Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице.
// <script>
// alert( document.body.innerHTML ); // читаем текущее содержимое
// document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое
// </script>
// Скрипты не выполнятся
// Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.
// Будьте внимательны: «innerHTML+=» осуществляет перезапись
// innerHTML+= делает следующее:
// Старое содержимое удаляется.
// На его место становится новое значение innerHTML (с добавленной строкой).
// Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.
// Есть и другие побочные эффекты. Например, если существующий текст выделен мышкой, то при переписывании
// innerHTML большинство браузеров снимут выделение. А если это поле ввода <input> с текстом, введённым
// пользователем, то текст будет удалён. И т.д.

// outerHTML: HTML элемента целиком
// Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.
// Будьте осторожны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.
// то использование outerHTML не изменяет DOM-элемент, а удаляет его из внешнего контекста и вставляет вместо него новый HTML-код.

// nodeValue/data: содержимое текстового узла
// Свойство innerHTML есть только у узлов-элементов.
// У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data
// Иногда их используют для вставки информации и инструкций шаблонизатора в HTML

// textContent: просто текст
// Свойство textContent предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>.ъ
// Намного полезнее возможность записывать текст в textContent, т.к. позволяет писать текст «безопасным способом».

// Свойство «hidden»
// Атрибут и DOM-свойство «hidden» указывает на то, видим ли мы элемент или нет.
// Технически, hidden работает так же, как style="display:none". Но его применение проще.

// Другие свойства
// У DOM-элементов есть дополнительные свойства, в частности, зависящие от класса:

// value – значение для <input>, <select> и <textarea> (HTMLInputElement, HTMLSelectElement…).
// href – адрес ссылки «href» для <a href="..."> (HTMLAnchorElement).
// id – значение атрибута «id» для всех элементов (HTMLElement).
// …и многие другие…

// Итого
// Каждый DOM-узел принадлежит определённому классу. Классы формируют иерархию. Весь набор свойств и методов является результатом наследования.

// Главные свойства DOM-узла:
// nodeType
// Свойство nodeType позволяет узнать тип DOM-узла. Его значение – числовое: 1 для элементов,3 для текстовых узлов, и т.д. Только для чтения.
// nodeName/tagName
// Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима).
//  Для узлов-неэлементов nodeName описывает, что это за узел. Только для чтения.
// innerHTML
// Внутреннее HTML-содержимое узла-элемента. Можно изменять.
// outerHTML
// Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.
// nodeValue/data
// Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем data. Можно изменять.
// textContent
// Текст внутри элемента: HTML за вычетом всех <тегов>. Запись в него помещает текст в элемент, при этом все специальные
//  символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.
// hidden
// Когда значение установлено в true, делает то же самое, что и CSS display:none.
// В зависимости от своего класса DOM-узлы имеют и другие свойства. Например у элементов <input> (HTMLInputElement) есть свойства value,
//  type, у элементов <a> (HTMLAnchorElement) есть href и т.д. Большинство стандартных HTML-атрибутов имеют соответствующие свойства DOM.

// 1.6 Атрибуты и свойства

// Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты.
// Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.

// DOM-свойства
// DOM-узлы – это обычные объекты JavaScript
// Итак, DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:
// Им можно присвоить любое значение.
// Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).

// HTML-атрибуты
// В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов,
// он распознаёт стандартные атрибуты и создаёт DOM-свойства для них.
// Таким образом, когда у элемента есть id или другой стандартный атрибут, создаётся соответствующее свойство.
//  Но этого не происходит, если атрибут нестандартный.

//  Все атрибуты доступны с помощью следующих методов:
// elem.hasAttribute(name) – проверяет наличие атрибута.
// elem.getAttribute(name) – получает значение атрибута.
// elem.setAttribute(name, value) – устанавливает значение атрибута.
// elem.removeAttribute(name) – удаляет атрибут.
// Кроме этого, получить все атрибуты элемента можно с помощью свойства elem.attributes:
// коллекция объектов, которая принадлежит ко встроенному классу Attr со свойствами name и value.
// У HTML-атрибутов есть следующие особенности:
// Их имена регистронезависимы (id то же самое, что и ID).
// Их значения всегда являются строками.
// Пожалуйста, обратите внимание:
// getAttribute('About') – здесь первая буква заглавная, а в HTML – строчная. Но это не важно: имена атрибутов регистронезависимы.
// Мы можем присвоить что угодно атрибуту, но это станет строкой. Поэтому в этой строчке мы получаем значение "123".
// Все атрибуты, в том числе те, которые мы установили, видны в outerHTML.
// Коллекция attributes является перебираемой. В ней есть все атрибуты элемента (стандартные и нестандартные)
// в виде объектов со свойствами name и value.

// Синхронизация между атрибутами и свойствами
// DOM-свойства типизированы
// DOM-свойства не всегда являются строками. Например, свойство input.checked (для чекбоксов) имеет логический тип
// Атрибут style – строка, но свойство style является объектом

// Нестандартные атрибуты, dataset
// Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset.
// Атрибуты, состоящие из нескольких слов, к примеру data-order-state, становятся свойствами,
//  записанными с помощью верблюжьей нотации: dataset.orderState.

//  Итого
// Атрибуты – это то, что написано в HTML.
// Свойства – это то, что находится в DOM-объектах.

// Свойства	                                                                        Атрибуты
// Тип	Любое значение, стандартные свойства имеют типы, описанные в спецификации	Строка
// Имя	Имя регистрозависимо	                                                    Имя регистронезависимо

// Методы для работы с атрибутами:
// elem.hasAttribute(name) – проверить на наличие.
// elem.getAttribute(name) – получить значение.
// elem.setAttribute(name, value) – установить значение.
// elem.removeAttribute(name) – удалить атрибут.
// elem.attributes – это коллекция всех атрибутов.
// В большинстве ситуаций предпочтительнее использовать DOM-свойства. Нужно использовать атрибуты только тогда,
//  когда DOM-свойства не подходят, когда нужны именно атрибуты, например:
// Нужен нестандартный атрибут. Но если он начинается с data-, тогда нужно использовать dataset.
// Мы хотим получить именно то значение, которое написано в HTML. Значение DOM-свойства может быть другим, например,
// свойство href – всегда полный URL, а нам может понадобиться получить «оригинальное» значение.

// 1.7 Изменение документа

// Модификации DOM – это ключ к созданию «живых» страниц.
// Создание элемента
// DOM-узел можно создать двумя методами:
// document.createElement(tag)
// Создаёт новый элемент с заданным тегом:
// let div = document.createElement('div');
// document.createTextNode(text)
// Создаёт новый текстовый узел с заданным текстом:
// let textNode = document.createTextNode('А вот и я');

// Создание сообщения
// В нашем случае сообщение – это div с классом alert и HTML в нём:
// let div = document.createElement('div');
// div.className = "alert";
// div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";

// Методы вставки
// Чтобы наш div появился, нам нужно вставить его где-нибудь в document. Например, в document.body.
// Для этого есть метод append, в нашем случае: document.body.append(div).
// Если нам нужно переместить элемент в другое место – нет необходимости удалять его со старого.
// Все методы вставки автоматически удаляют узлы со старых мест.

// DocumentFragment
// DocumentFragment является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.

// Несколько слов о «document.write»
// Вызов document.write работает только во время загрузки страницы.

// Итого
// Методы для создания узлов:
// document.createElement(tag) – создаёт элемент с заданным тегом,
// document.createTextNode(value) – создаёт текстовый узел (редко используется),
// elem.cloneNode(deep) – клонирует элемент, если deep==true, то со всеми дочерними элементами.
// Вставка и удаление:
// node.append(...nodes or strings) – вставляет в node в конец,
// node.prepend(...nodes or strings) – вставляет в node в начало,
// node.before(...nodes or strings) – вставляет прямо перед node,
// node.after(...nodes or strings) – вставляет сразу после node,
// node.replaceWith(...nodes or strings) – заменяет node.
// node.remove() – удаляет node.
// Устаревшие методы:
// parent.appendChild(node)
// parent.insertBefore(node, nextSibling)
// parent.removeChild(node)
// parent.replaceChild(newElem, node)
// Все эти методы возвращают node.
// Если нужно вставить фрагмент HTML, то elem.insertAdjacentHTML(where, html) вставляет в зависимости от where:
// "beforebegin" – вставляет html прямо перед elem,
// "afterbegin" – вставляет html в elem в начало,
// "beforeend" – вставляет html в elem в конец,
// "afterend" – вставляет html сразу после elem.
// Также существуют похожие методы elem.insertAdjacentText и elem.insertAdjacentElement, они вставляют текстовые строки и элементы,
//  но они редко используются.
// Чтобы добавить HTML на страницу до завершения её загрузки:
// document.write(html)
// После загрузки страницы такой вызов затирает документ. В основном встречается в старых скриптах.

// 1.8 Стили и классы
