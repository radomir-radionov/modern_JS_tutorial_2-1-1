///  Modern JavaScript tutorial  ///

// ЧАСТЬ 2
// Браузер: документ, события, интерфейсы
// Изучаем работу со страницей – как получать элементы, манипулировать их размерами,
// динамически создавать интерфейсы и взаимодействовать с посетителем.

// 1.1 Браузерное окружение, спецификации

// Каждая среда предоставляет свою функциональность, которую спецификация JavaScript называет окружением.
// Окружение предоставляет свои объекты и дополнительные функции, в дополнение базовым языковым.
// имеется корневой объект window, который выступает в 2 ролях:
// Во-первых, это глобальный объект(Глобальный объект предоставляет переменные и функции, доступные в любом месте программы.)
// для JavaScript-кода, об этом более подробно говорится в главе Глобальный объект.
// Во-вторых, он также представляет собой окно браузера и располагает методами для управления им.

// DOM (Document Object Model)
// Document Object Model, сокращённо DOM – объектная модель документа, которая представляет все содержимое
//  страницы в виде объектов, которые можно менять.
//  Объект document – основная «входная точка». С его помощью мы можем что-то создавать или менять на странице.
//  DOM – не только для браузеров
// Спецификация DOM описывает структуру документа и предоставляет объекты для манипуляций со страницей.

// BOM (Browser Object Model)
// Объектная модель браузера (Browser Object Model, BOM) – это дополнительные объекты,
//  предоставляемые браузером (окружением), чтобы работать со всем, кроме документа.
// Например:
// Объект navigator даёт информацию о самом браузере и операционной системе. Среди множества его
// свойств самыми известными являются: navigator.userAgent – информация о текущем браузере,
// и navigator.platform – информация о платформе (может помочь в понимании того, в какой ОС открыт браузер – Windows/Linux/Mac и так далее).
// Объект location позволяет получить текущий URL и перенаправить браузер по новому адресу.

// Итого
// Говоря о стандартах, у нас есть:
// Спецификация DOM
// описывает структуру документа, манипуляции с контентом и события, подробнее на https://dom.spec.whatwg.org.
// Спецификация CSSOM
// Описывает файлы стилей, правила написания стилей и манипуляций с ними, а также то, как это всё связано со страницей,
// подробнее на https://www.w3.org/TR/cssom-1/.
// Спецификация HTML
// Описывает язык HTML (например, теги) и BOM (объектную модель браузера) – разные функции браузера: setTimeout, alert,
// location и так далее, подробнее на https://html.spec.whatwg.org. Тут берётся за основу спецификация DOM и
// расширяется дополнительными свойствами и методами.

// 1.2 DOM-дерево

// Основой HTML-документа являются теги.
// В соответствии с объектной моделью документа («Document Object Model», коротко DOM), каждый HTML-тег является объектом.
// Вложенные теги являются «детьми» родительского элемента. Текст, который находится внутри тега, также является объектом.
// DOM – это представление HTML-документа в виде дерева тегов.
// Каждый узел этого дерева – это объект.
// Теги являются узлами-элементами (или просто элементами). Они образуют структуру дерева: <html> – это корневой узел,
// <head> и <body> его дочерние узлы и т.д.
// Текст внутри элементов образует текстовые узлы, обозначенные как #text. Текстовый узел содержит в себе только строку текста.
// У него не может быть потомков, т.е. он находится всегда на самом нижнем уровне.
// Существует всего два исключения из этого правила:
// По историческим причинам пробелы и перевод строки перед тегом <head> игнорируются
// Если мы записываем что-либо после закрывающего тега </body>, браузер автоматически перемещает эту запись в конец body,
//  поскольку спецификация HTML требует, чтобы всё содержимое было внутри <body>. Поэтому после закрывающего тега </body>
//  не может быть никаких пробелов.

//  Автоисправление
// Если браузер сталкивается с некорректно написанным HTML-кодом, он автоматически корректирует его при построении DOM.
// Таблицы всегда содержат <tbody></tbody>

// Другие типы узлов
// Есть и некоторые другие типы узлов, кроме элементов и текстовых узлов.
// Например, узел-комментарий:
// Все, что есть в HTML, даже комментарии, является частью DOM.

// Существует 12 типов узлов. Но на практике мы в основном работаем с 4 из них:

// document – «входная точка» в DOM.
// узлы-элементы – HTML-теги, основные строительные блоки.
// текстовые узлы – содержат текст.
// комментарии – иногда в них можно включить информацию, которая не будет показана, но доступна в DOM для чтения JS.
// В правой части инструментов разработчика находятся следующие подразделы:
// Styles – здесь мы видим CSS, применённый к текущему элементу: правило за правилом, включая встроенные стили (выделены серым).
// Почти всё можно отредактировать на месте, включая размеры, внешние и внутренние отступы.
// Computed – здесь мы видим итоговые CSS-свойства элемента, которые он приобрёл в результате применения всего каскада стилей
// (в том числе унаследованные свойства и т.д.).
// Event Listeners – в этом разделе мы видим обработчики событий, привязанные к DOM-элементам (мы поговорим о них в следующей части учебника).
// … и т.д.

// Итого;
// HTML/XML документы представлены в браузере в виде DOM-дерева.
// Теги становятся узлами-элементами и формируют структуру документа.
// Текст становится текстовыми узлами.
// … и т.д. Всё, что записано в HTML, есть и в DOM-дереве, даже комментарии.
// Для изменения элементов или проверки DOM-дерева мы можем использовать инструменты разработчика в браузере.

// 1.3 Навигация по DOM-элементам

// DOM позволяет нам делать что угодно с элементами и их содержимым, но для начала нужно получить соответствующий DOM-объект.
// Все операции с DOM начинаются с объекта document. Это главная «точка входа» в DOM. Из него мы можем получить доступ к любому узлу.
// document.body может быть равен null
// В DOM значение null значит «не существует» или «нет такого узла».
// Дети: childNodes, firstChild, lastChild
// Коллекция childNodes содержит список всех детей, включая текстовые узлы.
// Свойства firstChild и lastChild обеспечивают быстрый доступ к первому и последнему дочернему элементу.

// DOM-коллекции
// Как мы уже видели, childNodes похож на массив. На самом деле это не массив, а коллекция – особый перебираемый объект-псевдомассив.
// Для перебора коллекции мы можем использовать for..of:
// for (let node of document.body.childNodes) {
//   alert(node); // покажет все узлы из коллекции
// }
// Это работает, потому что коллекция является перебираемым объектом (есть требуемый для этого метод Symbol.iterator).
// Методы массивов не будут работать, потому что коллекция – это не массив

// DOM-коллекции – только для чтения
// DOM-коллекции живые
// Не используйте цикл for..in для перебора коллекций

// Соседи и родитель
// Соседи – это узлы, у которых один и тот же родитель.
// Родитель доступен через parentNode.

// Навигация только по элементам
// дополнительный набор ссылок, которые учитывают только узлы-элементы:
// children – коллекция детей, которые являются элементами.
// firstElementChild, lastElementChild – первый и последний дочерний элемент.
// previousElementSibling, nextElementSibling – соседи-элементы.
// parentElement – родитель-элемент.
// Свойство parentElement возвращает родитель-элемент, а parentNode возвращает «любого родителя».
// Обычно эти свойства одинаковы: они оба получают родителя.
// Ещё немного ссылок: таблицы
// Элемент <table>, в дополнение к свойствам, о которых речь шла выше, поддерживает следующие:
// table.rows – коллекция строк <tr> таблицы.
// table.caption/tHead/tFoot – ссылки на элементы таблицы <caption>, <thead>, <tfoot>.
// table.tBodies – коллекция элементов таблицы <tbody> (по спецификации их может быть больше одного).
// <thead>, <tfoot>, <tbody> предоставляют свойство rows:
// tbody.rows – коллекция строк <tr> секции.
// <tr>:
// tr.cells – коллекция <td> и <th> ячеек, находящихся внутри строки <tr>.
// tr.sectionRowIndex – номер строки <tr> в текущей секции <thead>/<tbody>/<tfoot>.
// tr.rowIndex – номер строки <tr> в таблице (включая все строки таблицы).
// <td> and <th>:
// td.cellIndex – номер ячейки в строке <tr>.

// Итого
// Получив DOM-узел, мы можем перейти к его ближайшим соседям используя навигационные ссылки.
// Есть два основных набора ссылок:
// Для всех узлов: parentNode, childNodes, firstChild, lastChild, previousSibling, nextSibling.
// Только для узлов-элементов: parentElement, children, firstElementChild, lastElementChild, previousElementSibling, nextElementSibling.
// Некоторые виды DOM-элементов, например таблицы, предоставляют дополнительные ссылки и коллекции для доступа к своему содержимому.

// 1.4 Поиск: getElement*, querySelector*

// document.getElementById или просто id
// Если у элемента есть атрибут id, то мы можем получить его вызовом document.getElementById(id), где бы он ни находился.
// Значение id должно быть уникальным
// Только document.getElementById, а не anyElem.getElementById
// Метод getElementById можно вызвать только для объекта document. Он осуществляет поиск по id по всему документу.
// querySelectorAll
// Самый универсальный метод поиска – это elem.querySelectorAll(css), он возвращает все
// элементы внутри elem, удовлетворяющие данному CSS-селектору.
// Псевдоклассы тоже работают
// Псевдоклассы в CSS-селекторе, в частности :hover и :active, также поддерживаются. Например,
// document.querySelectorAll(':hover') вернёт коллекцию (в порядке вложенности: от внешнего к внутреннему)
// из текущих элементов под курсором мыши.

// matches
// Предыдущие методы искали по DOM.
// Метод elem.matches(css) ничего не ищет, а проверяет, удовлетворяет ли elem CSS-селектору, и возвращает true или false.
// if (elem.matches('a[href$="zip"]'))

// closest
// Метод elem.closest(css) ищет ближайшего предка, который соответствует CSS-селектору. Сам элемент также включается в поиск.
// Другими словами, метод closest поднимается вверх от элемента и проверяет каждого из родителей.
// Если он соответствует селектору, поиск прекращается. Метод возвращает либо предка, либо null, если такой элемент не найден.

// getElementsBy*
// На данный момент, они скорее исторические, так как querySelector более чем эффективен.
// Здесь мы рассмотрим их для полноты картины, также вы можете встретить их в старом коде.
// elem.getElementsByTagName(tag) ищет элементы с данным тегом и возвращает их коллекцию. Передав "*" вместо тега, можно получить всех потомков.
// elem.getElementsByClassName(className) возвращает элементы, которые имеют данный CSS-класс.
// document.getElementsByName(name) возвращает элементы с заданным атрибутом name. Очень редко используется.

// Живые коллекции
// Все методы "getElementsBy*" возвращают живую коллекцию.
// Такие коллекции всегда отражают текущее состояние документа и автоматически обновляются при его изменении.
// Напротив, querySelectorAll возвращает статическую коллекцию. Это похоже на фиксированный массив элементов.
// Итого
// Есть 6 основных методов поиска элементов в DOM:

// Метод	Ищет по...	Ищет внутри элемента?	Возвращает живую коллекцию?
// querySelector	CSS-selector	✔	-
// querySelectorAll	CSS-selector	✔	-
// getElementById	id	-	-
// getElementsByName	name	-	✔
// getElementsByTagName	tag or '*'	✔	✔
// getElementsByClassName	class	✔	✔
// Безусловно, наиболее часто используемыми в настоящее время являются методы querySelector и querySelectorAll,
//  но и методы getElement(s)By* могут быть полезны в отдельных случаях, а также встречаются в старом коде.
// Кроме того:
// Есть метод elem.matches(css), который проверяет, удовлетворяет ли элемент CSS-селектору.
// Метод elem.closest(css) ищет ближайшего по иерархии предка, соответствующему данному CSS-селектору. Сам элемент также включён в поиск.
// И, напоследок, давайте упомянем ещё один метод, который проверяет наличие отношений между предком и потомком:
// elemA.contains(elemB) вернёт true, если elemB находится внутри elemA (elemB потомок elemA) или когда elemA==elemB.

// 1.5 Свойства узлов: тип, тег и содержимое

// Классы DOM-узлов
// У разных DOM-узлов могут быть разные свойства. (a   input)
// Существуют следующие классы:
// Существуют следующие классы:
// EventTarget – это корневой «абстрактный» класс. Объекты этого класса никогда не создаются. Он служит основой,
// благодаря которой все DOM-узлы поддерживают так называемые «события», о которых мы поговорим позже.

// Node – также является «абстрактным» классом, и служит основой для DOM-узлов. Он обеспечивает базовую функциональность:
//  parentNode, nextSibling, childNodes и т.д. (это геттеры). Объекты класса Node никогда не создаются. Но есть определённые
//   классы узлов, которые наследуют от него: Text – для текстовых узлов, Element – для узлов-элементов и более экзотический
//   Comment – для узлов-комментариев.

// Element – это базовый класс для DOM-элементов. Он обеспечивает навигацию на уровне элементов: nextElementSibling, children
// и методы поиска: getElementsByTagName, querySelector. Браузер поддерживает не только HTML, но также XML и SVG. Класс Element
//  служит базой для следующих классов: SVGElement, XMLElement и HTMLElement.

// HTMLElement – является базовым классом для всех остальных HTML-элементов. От него наследуют конкретные элементы:
// HTMLInputElement – класс для тега <input>,
// HTMLBodyElement – класс для тега <body>,
// HTMLAnchorElement – класс для тега <a>,

// Для того, чтобы узнать имя класса DOM-узла, вспомним, что обычно у объекта есть свойство constructor.
//  Оно ссылается на конструктор класса, и в свойстве constructor.name содержится его имя:
// alert( document.body.constructor.name ); // HTMLBodyElement
// …Или мы можем просто привести его к строке:
// alert( document.body ); // [object HTMLBodyElement]
// Проверить наследование можно также при помощи instanceof

// Как видно, DOM-узлы – это обычные JavaScript объекты. Для наследования они используют классы, основанные на прототипах.
// console.dir(elem) и console.log(elem)
// Большинство браузеров поддерживают в инструментах разработчика две команды: console.log и console.dir.
//  Они выводят свои аргументы в консоль. Для JavaScript-объектов эти команды обычно выводят одно и то же.
// Но для DOM-элементов они работают по-разному:
// console.log(elem) выводит элемент в виде DOM-дерева.
// console.dir(elem) выводит элемент в виде DOM-объекта, что удобно для анализа его свойств.

// Свойство «nodeType»
// Свойство nodeType предоставляет ещё один, «старомодный» способ узнать «тип» DOM-узла.
// Его значением является цифра:
// elem.nodeType == 1 для узлов-элементов,
// elem.nodeType == 3 для текстовых узлов,
// elem.nodeType == 9 для объектов документа,
// В спецификации можно посмотреть остальные значения.
// В современных скриптах, чтобы узнать тип узла, мы можем использовать метод instanceof и другие способы проверить класс,
// но иногда nodeType проще использовать. Мы не можем изменить значение nodeType, только прочитать его.

// Тег: nodeName и tagName
// Получив DOM-узел, мы можем узнать имя его тега из свойств nodeName и tagName:
// Есть ли какая-то разница между tagName и nodeName?
// Да, она отражена в названиях свойств, но не очевидна.
// Свойство tagName есть только у элементов Element.
// Свойство nodeName определено для любых узлов Node:
// для элементов оно равно tagName.
// для остальных типов узлов (текст, комментарий и т.д.) оно содержит строку с типом узла.
// Другими словами, свойство tagName есть только у узлов-элементов (поскольку они происходят от класса Element),
// а nodeName может что-то сказать о других типах узлов.

//  innerHTML: содержимое элемента
// Свойство innerHTML позволяет получить HTML-содержимое элемента в виде строки.
// Мы также можем изменять его. Это один из самых мощных способов менять содержимое на странице.
// <script>
// alert( document.body.innerHTML ); // читаем текущее содержимое
// document.body.innerHTML = 'Новый BODY!'; // заменяем содержимое
// </script>
// Скрипты не выполнятся
// Если innerHTML вставляет в документ тег <script> – он становится частью HTML, но не запускается.
// Будьте внимательны: «innerHTML+=» осуществляет перезапись
// innerHTML+= делает следующее:
// Старое содержимое удаляется.
// На его место становится новое значение innerHTML (с добавленной строкой).
// Так как содержимое «обнуляется» и переписывается заново, все изображения и другие ресурсы будут перезагружены.
// Есть и другие побочные эффекты. Например, если существующий текст выделен мышкой, то при переписывании
// innerHTML большинство браузеров снимут выделение. А если это поле ввода <input> с текстом, введённым
// пользователем, то текст будет удалён. И т.д.

// outerHTML: HTML элемента целиком
// Свойство outerHTML содержит HTML элемента целиком. Это как innerHTML плюс сам элемент.
// Будьте осторожны: в отличие от innerHTML, запись в outerHTML не изменяет элемент. Вместо этого элемент заменяется целиком во внешнем контексте.
// то использование outerHTML не изменяет DOM-элемент, а удаляет его из внешнего контекста и вставляет вместо него новый HTML-код.

// nodeValue/data: содержимое текстового узла
// Свойство innerHTML есть только у узлов-элементов.
// У других типов узлов, в частности, у текстовых, есть свои аналоги: свойства nodeValue и data
// Иногда их используют для вставки информации и инструкций шаблонизатора в HTML

// textContent: просто текст
// Свойство textContent предоставляет доступ к тексту внутри элемента за вычетом всех <тегов>.ъ
// Намного полезнее возможность записывать текст в textContent, т.к. позволяет писать текст «безопасным способом».

// Свойство «hidden»
// Атрибут и DOM-свойство «hidden» указывает на то, видим ли мы элемент или нет.
// Технически, hidden работает так же, как style="display:none". Но его применение проще.

// Другие свойства
// У DOM-элементов есть дополнительные свойства, в частности, зависящие от класса:

// value – значение для <input>, <select> и <textarea> (HTMLInputElement, HTMLSelectElement…).
// href – адрес ссылки «href» для <a href="..."> (HTMLAnchorElement).
// id – значение атрибута «id» для всех элементов (HTMLElement).
// …и многие другие…

// Итого
// Каждый DOM-узел принадлежит определённому классу. Классы формируют иерархию. Весь набор свойств и методов является результатом наследования.

// Главные свойства DOM-узла:
// nodeType
// Свойство nodeType позволяет узнать тип DOM-узла. Его значение – числовое: 1 для элементов,3 для текстовых узлов, и т.д. Только для чтения.
// nodeName/tagName
// Для элементов это свойство возвращает название тега (записывается в верхнем регистре, за исключением XML-режима).
//  Для узлов-неэлементов nodeName описывает, что это за узел. Только для чтения.
// innerHTML
// Внутреннее HTML-содержимое узла-элемента. Можно изменять.
// outerHTML
// Полный HTML узла-элемента. Запись в elem.outerHTML не меняет elem. Вместо этого она заменяет его во внешнем контексте.
// nodeValue/data
// Содержимое узла-неэлемента (текст, комментарий). Эти свойства практически одинаковые, обычно мы используем data. Можно изменять.
// textContent
// Текст внутри элемента: HTML за вычетом всех <тегов>. Запись в него помещает текст в элемент, при этом все специальные
//  символы и теги интерпретируются как текст. Можно использовать для защиты от вставки произвольного HTML кода.
// hidden
// Когда значение установлено в true, делает то же самое, что и CSS display:none.
// В зависимости от своего класса DOM-узлы имеют и другие свойства. Например у элементов <input> (HTMLInputElement) есть свойства value,
//  type, у элементов <a> (HTMLAnchorElement) есть href и т.д. Большинство стандартных HTML-атрибутов имеют соответствующие свойства DOM.

// 1.6 Атрибуты и свойства

// Когда браузер загружает страницу, он «читает» (также говорят: «парсит») HTML и генерирует из него DOM-объекты.
// Для узлов-элементов большинство стандартных HTML-атрибутов автоматически становятся свойствами DOM-объектов.

// DOM-свойства
// DOM-узлы – это обычные объекты JavaScript
// Итак, DOM-свойства и методы ведут себя так же, как и обычные объекты JavaScript:
// Им можно присвоить любое значение.
// Они регистрозависимы (нужно писать elem.nodeType, не elem.NoDeTyPe).

// HTML-атрибуты
// В HTML у тегов могут быть атрибуты. Когда браузер парсит HTML, чтобы создать DOM-объекты для тегов,
// он распознаёт стандартные атрибуты и создаёт DOM-свойства для них.
// Таким образом, когда у элемента есть id или другой стандартный атрибут, создаётся соответствующее свойство.
//  Но этого не происходит, если атрибут нестандартный.

//  Все атрибуты доступны с помощью следующих методов:
// elem.hasAttribute(name) – проверяет наличие атрибута.
// elem.getAttribute(name) – получает значение атрибута.
// elem.setAttribute(name, value) – устанавливает значение атрибута.
// elem.removeAttribute(name) – удаляет атрибут.
// Кроме этого, получить все атрибуты элемента можно с помощью свойства elem.attributes:
// коллекция объектов, которая принадлежит ко встроенному классу Attr со свойствами name и value.
// У HTML-атрибутов есть следующие особенности:
// Их имена регистронезависимы (id то же самое, что и ID).
// Их значения всегда являются строками.
// Пожалуйста, обратите внимание:
// getAttribute('About') – здесь первая буква заглавная, а в HTML – строчная. Но это не важно: имена атрибутов регистронезависимы.
// Мы можем присвоить что угодно атрибуту, но это станет строкой. Поэтому в этой строчке мы получаем значение "123".
// Все атрибуты, в том числе те, которые мы установили, видны в outerHTML.
// Коллекция attributes является перебираемой. В ней есть все атрибуты элемента (стандартные и нестандартные)
// в виде объектов со свойствами name и value.

// Синхронизация между атрибутами и свойствами
// DOM-свойства типизированы
// DOM-свойства не всегда являются строками. Например, свойство input.checked (для чекбоксов) имеет логический тип
// Атрибут style – строка, но свойство style является объектом

// Нестандартные атрибуты, dataset
// Все атрибуты, начинающиеся с префикса «data-», зарезервированы для использования программистами. Они доступны в свойстве dataset.
// Атрибуты, состоящие из нескольких слов, к примеру data-order-state, становятся свойствами,
//  записанными с помощью верблюжьей нотации: dataset.orderState.

//  Итого
// Атрибуты – это то, что написано в HTML.
// Свойства – это то, что находится в DOM-объектах.

// Свойства	                                                                        Атрибуты
// Тип	Любое значение, стандартные свойства имеют типы, описанные в спецификации	Строка
// Имя	Имя регистрозависимо	                                                    Имя регистронезависимо

// Методы для работы с атрибутами:
// elem.hasAttribute(name) – проверить на наличие.
// elem.getAttribute(name) – получить значение.
// elem.setAttribute(name, value) – установить значение.
// elem.removeAttribute(name) – удалить атрибут.
// elem.attributes – это коллекция всех атрибутов.
// В большинстве ситуаций предпочтительнее использовать DOM-свойства. Нужно использовать атрибуты только тогда,
//  когда DOM-свойства не подходят, когда нужны именно атрибуты, например:
// Нужен нестандартный атрибут. Но если он начинается с data-, тогда нужно использовать dataset.
// Мы хотим получить именно то значение, которое написано в HTML. Значение DOM-свойства может быть другим, например,
// свойство href – всегда полный URL, а нам может понадобиться получить «оригинальное» значение.

// 1.7 Изменение документа

// Модификации DOM – это ключ к созданию «живых» страниц.
// Создание элемента
// DOM-узел можно создать двумя методами:
// document.createElement(tag)
// Создаёт новый элемент с заданным тегом:
// let div = document.createElement('div');
// document.createTextNode(text)
// Создаёт новый текстовый узел с заданным текстом:
// let textNode = document.createTextNode('А вот и я');

// Создание сообщения
// В нашем случае сообщение – это div с классом alert и HTML в нём:
// let div = document.createElement('div');
// div.className = "alert";
// div.innerHTML = "<strong>Всем привет!</strong> Вы прочитали важное сообщение.";

// Методы вставки
// Чтобы наш div появился, нам нужно вставить его где-нибудь в document. Например, в document.body.
// Для этого есть метод append, в нашем случае: document.body.append(div).
// Если нам нужно переместить элемент в другое место – нет необходимости удалять его со старого.
// Все методы вставки автоматически удаляют узлы со старых мест.

// DocumentFragment
// DocumentFragment является специальным DOM-узлом, который служит обёрткой для передачи списков узлов.

// Несколько слов о «document.write»
// Вызов document.write работает только во время загрузки страницы.

// Итого
// Методы для создания узлов:
// document.createElement(tag) – создаёт элемент с заданным тегом,
// document.createTextNode(value) – создаёт текстовый узел (редко используется),
// elem.cloneNode(deep) – клонирует элемент, если deep==true, то со всеми дочерними элементами.
// Вставка и удаление:
// node.append(...nodes or strings) – вставляет в node в конец,
// node.prepend(...nodes or strings) – вставляет в node в начало,
// node.before(...nodes or strings) – вставляет прямо перед node,
// node.after(...nodes or strings) – вставляет сразу после node,
// node.replaceWith(...nodes or strings) – заменяет node.
// node.remove() – удаляет node.
// Устаревшие методы:
// parent.appendChild(node)
// parent.insertBefore(node, nextSibling)
// parent.removeChild(node)
// parent.replaceChild(newElem, node)
// Все эти методы возвращают node.
// Если нужно вставить фрагмент HTML, то elem.insertAdjacentHTML(where, html) вставляет в зависимости от where:
// "beforebegin" – вставляет html прямо перед elem,
// "afterbegin" – вставляет html в elem в начало,
// "beforeend" – вставляет html в elem в конец,
// "afterend" – вставляет html сразу после elem.
// Также существуют похожие методы elem.insertAdjacentText и elem.insertAdjacentElement, они вставляют текстовые строки и элементы,
//  но они редко используются.
// Чтобы добавить HTML на страницу до завершения её загрузки:
// document.write(html)
// После загрузки страницы такой вызов затирает документ. В основном встречается в старых скриптах.

// 1.8 Стили и классы

// className и classList

/* <body class="main page">
  <script>
    alert(document.body.className); // main page
  </script>
</body> */
// Если мы присваиваем что-то elem.className, то это заменяет всю строку с классами.

// elem.classList – это специальный объект с методами для добавления/удаления одного класса.
// Например:
// <body class="main page">
//   <script>
//     // добавление класса
//     document.body.classList.add('article');

//     alert(document.body.className); // main page article
//   </script>
// </body>

// Методы classList:
// elem.classList.add/remove("class") – добавить/удалить класс.
// elem.classList.toggle("class") – добавить класс, если его нет, иначе удалить.
// elem.classList.contains("class") – проверка наличия класса, возвращает true/false.
// Кроме того, classList является перебираемым, поэтому можно перечислить все классы при помощи for..of:
/* <body class="main page">
  <script>
    for (let name of document.body.classList) {
      alert(name); // main, затем page
    }
  </script>
</body> */

// Element style
// Свойство elem.style – это объект, который соответствует тому, что написано в атрибуте "style".
// Для свойства из нескольких слов используется camelCase:
// background-color  => elem.style.backgroundColor
// z-index           => elem.style.zIndex
// Например:
// document.body.style.backgroundColor = prompt('background color?', 'green');

// Сброс стилей
// Например, чтобы скрыть элемент, мы можем задать elem.style.display = "none".
// elem.style.display = "". Возврат

// Для задания нескольких стилей в одной строке используется специальное свойство style.cssText
// <div id="div">Button</div>
// <script>
//   // можем даже устанавливать специальные флаги для стилей, например, "important"
//   div.style.cssText=`color: red !important;
//     background-color: yellow;
//     width: 100px;
//     text-align: center;
//   `;

//   alert(div.style.cssText);
// </script>
// такое присваивание удаляет все существующие стили: оно не добавляет, а заменяет их.
// То же самое можно сделать установкой атрибута: div.setAttribute('style', 'color: red...').

// Вычисленные стили: getComputedStyle
// Свойство style оперирует только значением атрибута "style", без учёта CSS-каскада.
// если нам нужно, скажем, увеличить отступ на 20px? Для начала нужно его текущее значение получить.
// Для этого есть метод: getComputedStyle.
// Синтаксис:
// getComputedStyle(element, [pseudo])
// element
// Элемент, значения для которого нужно получить
// pseudo
// Указывается, если нужен стиль псевдоэлемента, например ::before. Пустая строка или отсутствие аргумента означают сам элемент.

// Итого
// Для управления классами существуют два DOM-свойства:
// className – строковое значение, удобно для управления всем набором классов.
// classList – объект с методами add/remove/toggle/contains, удобно для управления отдельными классами.
// Чтобы изменить стили:
// Свойство style является объектом со стилями в формате camelCase. Чтение и запись в него работают так же,
// как изменение соответствующих свойств в атрибуте "style". Чтобы узнать, как добавить в него important и делать
// некоторые другие редкие вещи – смотрите документацию.
// Свойство style.cssText соответствует всему атрибуту "style", полной строке стилей.
// Для чтения окончательных стилей (с учётом всех классов, после применения CSS и вычисления окончательных значений) используется:
// Метод getComputedStyle(elem, [pseudo]) возвращает объект, похожий по формату на style. Только для чтения.

// let divbg = document.getElementById("bg-colour");

// // divbg.style.backgroundColor = "yellow";
// divbg.style.cssText = `color: red !important;
// background-color: yellow;
// width: 100px;
// height:100px;
// text-align: center;
// `;

// 2.1 Введение в браузерные события

// Событие – это сигнал от браузера о том, что что-то произошло. Все DOM-узлы подают такие сигналы (хотя события бывают и не только в DOM).
// События мыши:
// click – происходит, когда кликнули на элемент левой кнопкой мыши (на устройствах с сенсорными экранами оно происходит при касании).
// contextmenu – происходит, когда кликнули на элемент правой кнопкой мыши.
// mouseover / mouseout – когда мышь наводится на / покидает элемент.
// mousedown / mouseup – когда нажали / отжали кнопку мыши на элементе.
// mousemove – при движении мыши.
// События на элементах управления:
// submit – пользователь отправил форму <form>.
// focus – пользователь фокусируется на элементе, например нажимает на <input>.
// Клавиатурные события:
// keydown и keyup – когда пользователь нажимает / отпускает клавишу.
// События документа:
// DOMContentLoaded – когда HTML загружен и обработан, DOM документа полностью построен и доступен.
// CSS events:
// transitionend – когда CSS-анимация завершена.
// Существует множество других событий. Мы подробно разберём их в последующих главах.

// Обработчики событий
// Событию можно назначить обработчик, то есть функцию, которая сработает, как только событие произошло.

// Использование атрибута HTML
// Например, чтобы назначить обработчик события click на элементе input, можно использовать атрибут onclick, вот так:
// <input value="Нажми меня" onclick="alert('Клик!')" type="button"></input>
// Следующий пример по клику запускает функцию countRabbits():
// <script>
//   function countRabbits() {
//     for(let i=1; i<=3; i++) {
//       alert("Кролик номер " + i);
//     }
//   }
// </script>
// <input type="button" onclick="countRabbits()" value="Считать кроликов!"></input>

// Использование свойства DOM-объекта
// К примеру, elem.onclick:
// <input id="elem" type="button" value="Нажми меня!">
// <script>
//   elem.onclick = function() {
//     alert('Спасибо');
//   };
// </script>
// Обработчик всегда хранится в свойстве DOM-объекта, а атрибут – лишь один из способов его инициализации.
// Так как у элемента DOM может быть только одно свойство с именем onclick, то назначить более одного обработчика так нельзя.
// обработчиком можно назначить и уже существующую функцию:
// function sayThanks() {
//   alert('Спасибо!');
// }
// elem.onclick = sayThanks;
// Убрать обработчик можно назначением elem.onclick = null.

// Доступ к элементу через this
// Внутри обработчика события this ссылается на текущий элемент, то есть на тот, на котором, как говорят, «висит» (т.е. назначен) обработчик.
// В коде ниже button выводит своё содержимое, используя this.innerHTML:
// <button onclick="alert(this.innerHTML)">Нажми меня</button>

// Частые ошибки
// Функция должна быть присвоена как sayThanks, а не sayThanks().
// Если добавить скобки, то sayThanks() – это уже вызов функции, результат которого (равный undefined, так как функция ничего не возвращает)
// будет присвоен onclick. Так что это не будет работать.
// …А вот в разметке, в отличие от свойства, скобки нужны:
// <input type="button" id="button" onclick="sayThanks()"></input>
// Это различие просто объяснить. При создании обработчика браузером из атрибута, он автоматически создаёт функцию
// с телом из значения атрибута: sayThanks().
// Используйте именно функции, а не строки.
// Не используйте setAttribute для обработчиков.
// Регистр DOM-свойства имеет значение.

// addEventListener
// Фундаментальный недостаток описанных выше способов назначения обработчика –- невозможность повесить несколько обработчиков на одно событие.
// Синтаксис добавления обработчика:
// element.addEventListener(event, handler[, options]);
// event
// Имя события, например "click".
// handler
// Ссылка на функцию-обработчик.
// options
// Дополнительный объект со свойствами:
// once: если true, тогда обработчик будет автоматически удалён после выполнения.
// capture: фаза, на которой должен сработать обработчик, подробнее об этом будет рассказано
// в главе Всплытие и погружение. Так исторически сложилось, что options может быть false/true, это то же самое, что {capture: false/true}.
// passive: если true, то указывает, что обработчик никогда не вызовет preventDefault(),
// подробнее об этом будет рассказано в главе Действия браузера по умолчанию.
// Для удаления обработчика следует использовать removeEventListener:
// element.removeEventListener(event, handler[, options]);
// Удаление требует именно ту же функцию
// Метод addEventListener позволяет добавлять несколько обработчиков на одно событие одного элемента
// Обработчики некоторых событий можно назначать только через addEventListener

// Объект события
// Когда происходит событие, браузер создаёт объект события, записывает в него детали и передаёт его в качестве аргумента функции-обработчику.
// Некоторые свойства объекта event:
// event.type
// Тип события, в данном случае "click".
// event.currentTarget
// Элемент, на котором сработал обработчик. Значение – обычно такое же, как и у this, но если обработчик является
// функцией-стрелкой или при помощи bind привязан другой объект в качестве this, то мы можем получить элемент из event.currentTarget.
// event.clientX / event.clientY
// Координаты курсора в момент клика относительно окна, для событий мыши.
// Есть также и ряд других свойств, в зависимости от типа событий, которые мы разберём в дальнейших главах.

// Объект-обработчик: handleEvent
// Мы можем назначить обработчиком не только функцию, но и объект при помощи addEventListener. В этом случае,
// когда происходит событие, вызывается метод объекта handleEvent.
// Мы можем назначить обработчиком не только функцию, но и объект при помощи addEventListener. В этом случае,
//  когда происходит событие, вызывается метод объекта handleEvent.

//  Итого
// Есть три способа назначения обработчиков событий:
// Атрибут HTML: onclick="...".
// DOM-свойство: elem.onclick = function.
// Специальные методы: elem.addEventListener(event, handler[, phase]) для добавления, removeEventListener для удаления.
// HTML-атрибуты используются редко потому, что JavaScript в HTML-теге выглядит немного странно. К тому же много кода там не напишешь.
// DOM-свойства вполне можно использовать, но мы не можем назначить больше одного обработчика на один тип события.
// Во многих случаях с этим ограничением можно мириться.
// Последний способ самый гибкий, однако нужно писать больше всего кода. Есть несколько типов событий, которые работают
// только через него, к примеру transitionend и DOMContentLoaded. Также addEventListener поддерживает объекты в качестве
//  обработчиков событий. В этом случае вызывается метод объекта handleEvent.
// Не важно, как вы назначаете обработчик – он получает объект события первым аргументом. Этот объект содержит подробности о том, что произошло.

// 2.2 Всплытие и погружение

// Всплытие
// Когда на элементе происходит событие, обработчики сначала срабатывают на нём, потом на его родителе,
// затем выше и так далее, вверх по цепочке предков.
// Этот процесс называется «всплытием», потому что события «всплывают» от внутреннего элемента вверх через родителей подобно тому,
//  как всплывает пузырёк воздуха в воде.

//  Почти все события всплывают.
// Ключевое слово в этой фразе – «почти».
// Например, событие focus не всплывает.

// event.target
// Самый глубокий элемент, который вызывает событие, называется целевым элементом, и он доступен через event.target.
// Отличия от this (=event.currentTarget):
// event.target – это «целевой» элемент, на котором произошло событие, в процессе всплытия он неизменен.
// this – это «текущий» элемент, до которого дошло всплытие, на нём сейчас выполняется обработчик.

// Прекращение всплытия
// Всплытие идёт с «целевого» элемента прямо наверх. По умолчанию событие будет всплывать до элемента <html>,
// а затем до объекта document, а иногда даже до window, вызывая все обработчики на своём пути.
// Но любой промежуточный обработчик может решить, что событие полностью обработано, и остановить всплытие.
// Для этого нужно вызвать метод event.stopPropagation().
// event.stopImmediatePropagation()
// Если у элемента есть несколько обработчиков на одно событие, то даже при прекращении всплытия все они будут выполнены.
// То есть, event.stopPropagation() препятствует продвижению события дальше, но на текущем элементе все обработчики будут вызваны.
// Для того, чтобы полностью остановить обработку, существует метод event.stopImmediatePropagation().
// Он не только предотвращает всплытие, но и останавливает обработку событий на текущем элементе.

// Погружение
// Существует ещё одна фаза из жизненного цикла события – «погружение» (иногда её называют «перехват»).

// Стандарт DOM Events описывает 3 фазы прохода события:
// Фаза погружения (capturing phase) – событие сначала идёт сверху вниз.
// Фаза цели (target phase) – событие достигло целевого(исходного) элемента.
// Фаза всплытия (bubbling stage) – событие начинает всплывать.
// Ранее мы говорили только о всплытии, потому что другие стадии, как правило, не используются и проходят незаметно для нас.

// Обработчики, добавленные через on<event>-свойство или через HTML-атрибуты, или через addEventListener(event, handler)
//  с двумя аргументами, ничего не знают о фазе погружения, а работают только на 2-ой и 3-ей фазах.

//  Чтобы поймать событие на стадии погружения, нужно использовать третий аргумент capture вот так:
// elem.addEventListener(..., {capture: true})
// // или просто "true", как сокращение для {capture: true}
// elem.addEventListener(..., true)
// Существуют два варианта значений опции capture:
// Если аргумент false (по умолчанию), то событие будет поймано при всплытии.
// Если аргумент true, то событие будет перехвачено при погружении.

// Чтобы убрать обработчик removeEventListener, нужна та же фаза
// Если мы добавили обработчик вот так addEventListener(..., true), то мы должны передать то же значение аргумента
// capture в removeEventListener(..., true), когда снимаем обработчик.

// Итого
// При наступлении события – самый глубоко вложенный элемент, на котором оно произошло, помечается как «целевой» (event.target).

// Затем событие сначала двигается вниз от корня документа к event.target, по пути вызывая обработчики,
//  поставленные через addEventListener(...., true), где true – это сокращение для {capture: true}.
// Далее обработчики вызываются на целевом элементе.
// Далее событие двигается от event.target вверх к корню документа, по пути вызывая обработчики,
// поставленные через on<event> и addEventListener без третьего аргумента или с третьим аргументом равным false.
// Каждый обработчик имеет доступ к свойствам события event:
// event.target – самый глубокий элемент, на котором произошло событие.
// event.currentTarget (=this) – элемент, на котором в данный момент сработал обработчик (тот, на котором «висит» конкретный обработчик)
// event.eventPhase – на какой фазе он сработал (погружение=1, фаза цели=2, всплытие=3).
// Любой обработчик может остановить событие вызовом event.stopPropagation(), но делать это не рекомендуется,
// так как в дальнейшем это событие может понадобиться, иногда для самых неожиданных вещей.
// В современной разработке стадия погружения используется очень редко, обычно события обрабатываются во время всплытия. И в этом есть логика.

// 2.3 Делегирование событий

// Всплытие и перехват событий позволяет реализовать один из самых важных приёмов разработки – делегирование.
// Идея в том, что если у нас есть много элементов, события на которых нужно обрабатывать похожим образом,
//  то вместо того, чтобы назначать обработчик каждому, мы ставим один обработчик на их общего предка.
//  Из него можно получить целевой элемент event.target, понять на каком именно потомке произошло событие и обработать его.

//  Применение делегирования: действия в разметке

//  Приём проектирования «поведение»
//  Делегирование событий можно использовать для добавления элементам «поведения» (behavior),
//  декларативно задавая хитрые обработчики установкой специальных HTML-атрибутов и классов.
// Приём проектирования «поведение» состоит из двух частей:
// Элементу ставится пользовательский атрибут, описывающий его поведение.
// При помощи делегирования ставится обработчик на документ, который ловит все клики (или другие события) и,
// если элемент имеет нужный атрибут, производит соответствующее действие.
// Всегда используйте метод addEventListener для обработчиков на уровне документа

// Поведение: «Переключатель» (Toggler)
// Итого
// Делегирование событий – это здорово! Пожалуй, это один из самых полезных приёмов для работы с DOM.

// Он часто используется, если есть много элементов, обработка которых очень схожа, но не только для этого.

// Алгоритм:
// Вешаем обработчик на контейнер.
// В обработчике проверяем исходный элемент event.target.
// Если событие произошло внутри нужного нам элемента, то обрабатываем его.
// Зачем использовать:
// Упрощает процесс инициализации и экономит память: не нужно вешать много обработчиков.
// Меньше кода: при добавлении и удалении элементов не нужно ставить или снимать обработчики.
// Удобство изменений DOM: можно массово добавлять или удалять элементы путём изменения innerHTML и ему подобных.
// Конечно, у делегирования событий есть свои ограничения:
// Во-первых, событие должно всплывать. Некоторые события этого не делают. Также, низкоуровневые
// обработчики не должны вызывать event.stopPropagation().
// Во-вторых, делегирование создаёт дополнительную нагрузку на браузер, ведь обработчик запускается,
// когда событие происходит в любом месте контейнера, не обязательно на элементах, которые нам интересны.
//  Но обычно эта нагрузка настолько пустяковая, что её даже не стоит принимать во внимание.

// 2.4 Действия браузера по умолчанию

// Многие события автоматически влекут за собой действие браузера.
// Например:
// Клик по ссылке инициирует переход на новый URL.
// Нажатие на кнопку «отправить» в форме – отсылку её на сервер.
// Зажатие кнопки мыши над текстом и её движение в таком состоянии – инициирует его выделение.

// Отмена действия браузера
// Основной способ – это воспользоваться объектом event. Для отмены действия браузера существует стандартный метод event.preventDefault().
// Если же обработчик назначен через on<событие> (не через addEventListener), то также можно вернуть false из обработчика.
// Возвращать true не нужно
// Обычно значение, которое возвращает обработчик события, игнорируется.
// Единственное исключение – это return false из обработчика, назначенного через on<событие>.
// В других случаях return не нужен, он никак не обрабатывается.

// Пример: меню
// В HTML-разметке все элементы меню являются не кнопками, а ссылками, то есть тегами <a>.
//  В этом подходе есть некоторые преимущества, например:
// Некоторые посетители очень любят сочетание «правый клик – открыть в новом окне». Если мы будем использовать
//  <button> или <span>, то данное сочетание работать не будет.
// Поисковые движки переходят по ссылкам <a href="..."> при индексации.

// События, вытекающие из других
// Некоторые события естественным образом вытекают друг из друга. Если мы отменим первое событие, то последующие не возникнут.
// Например, событие mousedown для поля <input> приводит к фокусировке на нём и запускает событие focus.
// Если мы отменим событие mousedown, то фокусирования не произойдёт.

// Опция «passive» для обработчика

// Интерфейсные события

// 3.1 Основы событий мыши

// Типы событий мыши:

// -Простые события
// mousedown/mouseup
// Кнопка мыши нажата/отпущена над элементом.
// mouseover/mouseout
// Курсор мыши появляется над элементом и уходит с него.
// mousemove
// Каждое движение мыши над элементом генерирует это событие.
// contextmenu
// Вызывается при попытке открытия контекстного меню, как правило, нажатием правой кнопки мыши.
// Но, заметим, это не совсем событие мыши, оно может вызываться и специальной клавишей клавиатуры.

// Комплексные события
// click
// Вызывается при mousedown , а затем mouseup над одним и тем же элементом, если использовалась левая кнопка мыши.
// dblclick
// Вызывается двойным кликом на элементе.
// Комплексные события состоят из простых, поэтому в теории мы могли бы без них обойтись. Но хорошо,
// что они существуют, потому что работать с ними очень удобно.

// Порядок событий
// Например, клик мышью вначале вызывает mousedown, когда кнопка нажата, затем mouseup и click, когда она отпущена.
// В случае, когда одно действие инициирует несколько событий, порядок их выполнения фиксирован.
//  То есть обработчики событий вызываются в следующем порядке: mousedown → mouseup → click.

//  Получение информации о кнопке: which
//  События, связанные с кликом, всегда имеют свойство which, которое позволяет определить нажатую кнопку мыши.

//  Это свойство не используется для событий click и contextmenu,
//  поскольку первое происходит только при нажатии левой кнопкой мыши, а второе – правой.

// Модификаторы: shift, alt, ctrl и meta
// Свойства объекта события:
// shiftKey: Shift
// altKey: Alt (или Opt для Mac)
// ctrlKey: Ctrl
// metaKey: Cmd для Mac

// Координаты: clientX/Y, pageX/Y

// Относительно окна: clientX и clientY.
// Относительно документа: pageX и pageY.

// Отключаем выделение
// onmousedown="return false">

// предотвращение копирования
// Если мы хотим отключить выделение для защиты содержимого страницы от копирования,
//  то мы можем использовать другое событие: oncopy.

// Итого
// События мыши имеют следующие свойства:
// Кнопка: which.
// Клавиши-модификаторы (true если нажаты): altKey, ctrlKey, shiftKey и metaKey (Mac).
// Если вы планируете обработать Ctrl, то не забудьте, что пользователи Mac обычно используют Cmd,
//  поэтому лучше проверить if (e.metaKey || e.ctrlKey).
// Координаты относительно окна: clientX/clientY.
// Координаты относительно документа: pageX/pageY.
// Действие по умолчанию события mousedown – начало выделения, если в интерфейсе оно скорее мешает, его можно отменить.

// 3.2 Движение мыши: mouseover/out, mouseenter/leave

// События mouseover/mouseout, relatedTarget
// Событие mouseover происходит в момент, когда курсор оказывается над элементом,
// а событие mouseout – в момент, когда курсор уходит с элемента.

// Эти события являются особенными, потому что у них имеется свойство relatedTarget.
// Оно «дополняет» target. Когда мышь переходит с одного элемента на другой, то один из них будет target, а другой relatedTarget.
// Для события mouseover:
// event.target – это элемент, на который курсор перешёл.
// event.relatedTarget – это элемент, с которого курсор ушёл (relatedTarget → target).
// Для события mouseout наоборот:
// event.target – это элемент, с которого курсор ушёл.
// event.relatedTarget – это элемент, на который курсор перешёл (target → relatedTarget).

// Свойство relatedTarget может быть null
// Свойство relatedTarget может быть null.
// Это нормально и означает, что указатель мыши перешёл не с другого элемента,
// а из-за пределов окна браузера. Или же, наоборот, ушёл за пределы окна.

// Пропуск элементов

// Событие mousemove происходит при движении мыши. Однако, это не означает,
// что указанное событие генерируется при прохождении каждого пикселя.
// В частности, возможно, что указатель запрыгнет в середину страницы из-за пределов окна браузера.
// В этом случае значение relatedTarget будет null, так как курсор пришёл «из ниоткуда»:

// Событие mouseout при переходе на потомка
// Важная особенность события mouseout – оно генерируется в том числе, когда указатель переходит с элемента на его потомка.
// По логике браузера, курсор мыши может быть только над одним
// элементом в любой момент времени – над самым глубоко вложенным и верхним по z-index.
// При переходе с родителя элемента на потомка – на родителе сработают два обработчика: и mouseout и mouseover:
// События mouseenter и mouseleave

// События mouseenter/mouseleave похожи на mouseover/mouseout. Они тоже генерируются,
// когда курсор мыши переходит на элемент или покидает его.
// Но есть и пара важных отличий:
// Переходы внутри элемента, на его потомки и с них, не считаются.
// События mouseenter/mouseleave не всплывают.

// Делегирование событий
// События mouseenter/leave просты и легки в использовании. Но они не всплывают. Таким образом, мы не можем их делегировать.

// Итого
// Мы рассмотрели события mouseover, mouseout, mousemove, mouseenter и mouseleave.
// Особенности, на которые стоит обратить внимание:
// При быстром движении мыши события не будут возникать на промежуточных элементах.
// События mouseover/out и mouseenter/leave имеют дополнительное свойство: relatedTarget.
// Оно дополняет свойство target и содержит ссылку на элемент, с/на который мы переходим.
// События mouseover/out возникают, даже когда происходит переход с родительского элемента на потомка.
// С точки зрения браузера, курсор мыши может быть только над одним элементом в любой момент времени – над самым глубоко вложенным.
// События mouseenter/leave в этом отличаются. Они генерируются, когда курсор переходит на
// элемент в целом или уходит с него. Также они не всплывают.

// 3.4 Клавиатура: keydown и keyup

// События keydown и keyup
// Событие keydown происходит при нажатии клавиши, а keyup – при отпускании.
// event.code и event.key
// Свойство key объекта события позволяет получить символ, а свойство code – «физический код клавиши».
// Если пользователь работает с разными языками, то при переключении на другой язык символ изменится с "Z" на совершенно другой.
// Получившееся станет новым значением event.key, тогда как event.code останется тем же: "KeyZ".
// Обратите внимание, что event.code точно указывает, какая именно клавиша нажата.

// Автоповтор
// При долгом нажатии клавиши возникает автоповтор: keydown срабатывает снова и снова, и когда клавишу отпускают, то отрабатывает keyup.
// Так что ситуация, когда много keydownи один keyup, абсолютно нормальна.
// Для событий, вызванных автоповтором, у объекта события свойство event.repeat равно true.

// Действия по умолчанию весьма разнообразны, много чего можно инициировать нажатием на клавиатуре.
// Для примера:
// Появление символа (самое очевидное).
// Удаление символа (клавиша Delete).
// Прокрутка страницы (клавиша PageDown).
// Открытие диалогового окна браузера «Сохранить» (Ctrl+S)
// …и так далее.

// Итого
// Нажатие клавиши всегда генерирует клавиатурное событие, будь то буквенно-цифровая клавиша или специальная
// типа Shift или Ctrl и т.д. Единственным исключением является клавиша Fn, которая присутствует на
// клавиатуре некоторых ноутбуков. События на клавиатуре для неё нет, потому что она обычно работает на уровне более низком, чем даже ОС.
// События клавиатуры:
// keydown – при нажатии на клавишу (если клавиша остаётся нажатой, происходит автоповтор),
// keyup – при отпускании клавиши.
// Главные свойства для работы с клавиатурными событиями:
// code – «код клавиши» ("KeyA", "ArrowLeft" и так далее), особый код, привязанный
// к физическому расположению клавиши на клавиатуре.
// key – символ ("A", "a" и так далее), для не буквенно-цифровых групп клавиш
// (таких как Esc) обычно имеет то же значение, что и code.
// В прошлом события клавиатуры иногда использовались для отслеживания ввода данных
// пользователем в полях формы. Это ненадёжно, потому как ввод данных не обязательно
// может осуществляться с помощью клавиатуры. Существуют события input и change специально
// для обработки ввода (рассмотренные позже в главе События: change, input, cut, copy, paste).
//  Они срабатывают в результате любого ввода, включая Копировать/Вставить мышью и распознавание речи.
// События клавиатуры же должны использоваться только по назначению – для клавиатуры.
// Например, чтобы реагировать на горячие или специальные клавиши.

// 3.6 Прокрутка

// Событие прокрутки scroll позволяет реагировать на прокрутку страницы или элемента.
// Есть много хороших вещей, которые при этом можно сделать.
// Например:
// Показать/скрыть дополнительные элементы управления или информацию, основываясь
// на том, в какой части документа находится пользователь.
// Подгрузить данные, когда пользователь прокручивает страницу вниз до конца.
// Предотвращение прокрутки
// Как можно сделать что-то непрокручиваемым?
// Нельзя предотвратить прокрутку, используя event.preventDefault() в обработчике onscroll,
// потому что он срабатывает после того, как прокрутка уже произошла.
// Но можно предотвратить прокрутку, используя event.preventDefault() на событии,
// которое вызывает прокрутку, например, на событии keydown для клавиш pageUp и pageDown.
// Если поставить на них обработчики, в которых вызвать event.preventDefault(), то прокрутка не начнётся.
// Способов инициировать прокрутку много, поэтому более надёжный способ – использовать CSS, свойство overflow.
